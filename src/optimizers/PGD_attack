import torch


def pgd_attack(model: torch.nn, x: torch.Tensor, y:torch.Tensor, epsilon: float, alpha:float, num_iter, clamp_min: float = -1, clamp_max:float =1):
    x_adv = x.clone().detach().requires_grad_(True)
    for iter in range(num_iter):
        output = model(x_adv)
        loss = torch.nn.functional.cross_entropy(output, y)
        loss.backward()
        with torch.no_grad():
            x_adv += alpha* x_adv.grad.sfign()
            x_adv = torch.max(torch.min(x_adv, x + epsilon), x - epsilon) #if x_adv is outside of the ball, set it to the boundary of the ball so that x_adv belongs to [x-epsilon, x+epsilion]
            x_adv = torch.clamp(x_adv,clamp_min, clamp_max)
    return x_adv
